Java 
core java - super, this, final keywords, generics, recursion, collections(tree, graph,dequeue and queue), Optional (streams, lambda, functional interface),exception handling, Date timeAPI,Comparable vs Comparator.. memory management & garbage collection,
file handling, multithreading & concurrency

Git -> clear basics -> adding into repository, git init, git add, git commit, git push,  

git to be covered : stash, fetch, merge, rebase, status, pull, git branching

sql -> from scratch, jdbc connectivity

codekata -> walkthrough --> done -->  i/p stream & o/p stream.. java new features... 

javascript -> 1/2hr only taken, but not clear.. bootstrap.. html and css (margin, padding) -> react course videos will be received.

brush up of html & css, overview of bootstrap -> one session since the session was fast

js -> completely

*************************
18/04/24.
matrix problem
reading i/p from user
codekata

Problem solving skills -> 

divide and conquer..

IDE -> eclipse, sts (spring tool suite) -> almost similar
IntelliJ -> advanced features.. two types 1. community edition (free and open source), 2. ultimate edition (paid, free tier for first 15-30days)

jdk -> open jdk : oracle/amazon

jdk version should be compatible with IDE..

version 1 -> your game app..
playstore/app store -> version 2.. 

22/04/24

New Project -> select language, select build tool -> maven, gradle

packages -> classes -> methods/functions -> objects or variables (local & global)

.jar(.exe) -> build tools..

core java - super, this, final keywords: 

this : refers to current object 
super : refers to superclass or parent methods or variables
final : can't modify a value (variable), in case of class -> can't extend., method level -> can't overrride method

immutable -> can't modify 
	. make your class as final
	. make your fields as private
	. you will not have setters only getters
	. mutable fields final
	. initialize using a constructor

generics -> ensure type safety
	generic class(List), type parameters : T -> type, E -> element, K -> key, N -> number, V -> value
	generic method
	type casting -> from one data type you are converting to datatype

recursion -> making a function to call itself

collections -> framework (store data & manipulate data) -> search, sort, insertion, manipulation, deletion etc

				Iterable(interface)
				    ..

				  Collection

		List        Queue        Set     Map  


List -> insertion order, any number of null values
	ArrayList :  non-synchrnoized : add, remove, contains, get
	LinkedList :  non-synchrnoized : add, remove, contains, get
	Vector : synchronized : add, remove, contains, get
		. stack : push(add), insertion order Last In first Out : pop(remove), peek(top element), get

synchronous -> one action happens only at one time.. Collections.synchronizedList()

Queue : First in First Out : poll, remove, contains, peek, element
	. Priority queue - no insertion order
	. array dequeue - insertion order

Dequeue : add/delete the elements either at last or first position	

23/04/24

Set -> doesn't allow duplicates
	hashSet: not following insertion order, add, remove, contains., no indexing concept so get is not present.., one null will be allowed
	linkedhashset : follows insertion order, one null can be allowed
	treeSet : ascending order, no null values allowed, in case of null values -> run time exception

Map : store data in form of keys and values.. Keys will be unique, values can be duplicated


	Map<Integer, String> hashMap = new HashMap<>();
	hashMap.get(key) -> values
	hashMap.remove(1); -> remove both key and value
	hashMap.keySet() -> give you all the keys
	hashMap.containsKey(1) -> to check keys
	hashMap.containsValue("jill") -> to check values
	hashMap.entrySet() -> keys and values

	hashMap : One null key and multiple null values.
	treemap -> doesn't allow null key

hashtable, linked hash map.

stream API -> to process any collection of data	

Optional -> filter, map, entryset.stream

terenary operator -> condition ? true (statement will be executed) : false (whatever written here will be executed) --> if-else

Functional Interface -> @FunctionalInterface,

single abstract method, default or static or private methods in this..

abstract method in an interface should be overridden by the implemented class..

Types of functional interfaces -> Function, Consumer, Supplier, Predicate

Exception Handling:  (try, catch, finally, throw, throws)

	custom exception : extends exception, call parent constructor

DateTime API : changes in Java 8 -> Zoned, LocalDateTime, ChronoUnits, LocalDate, LocalTime, Period, Duration	

24/04/24:

Comparable vs Comparator.. file handling, memory management & garbage collection,

Comparable / Comparator -> sorting

File handling : create, read, update, delete, search

Asssignment:
create a folder -> 10 excel files with different names, using Java check if file exists or not and then if file is present delete a particular file. FileInputStream, type of functional interface

memory management & garbage collection:

Object destruction in JVM -> handled by garbage collector(GC), however few objects may not be eligible for GC then you will know to know how your memory is managed.

-Xmx2g
-Xms1g

string Pool -> FlyWeight Design Pattern

25/04/2024:

multithreading & concurrency, git commands

threads.. running llely, 
concurrency -> illusion that threads run parallely but real-time, they actually switch..

thread lifecycle -> new thread -> start() -> runnable -> run() -> runnning -> either wait for another thread or dead (execution ends)

payment process -> thread
receipt -> other thread..

when you wait for some thread to finish execution it's synchronous 
sign up to a site -> welcome email, even though you don't buy anything.. if you are not waiting for other thread or depending thread to finish execution -> asynchronous..

Thread Prioroties -> MAX_PRIORITY -> 10.. 

extending a thread, implementing Runnable/Callable -> create  a multi threaded environment.

Thread.interrupted -> wake up a sleeping thread

   System.out.println(Thread.currentThread().getName());
   Thread.currentThread().setName("Custom Name");

 Thread.join(); -> before start and after start.
 thread.setPriority(10) -> high

 one thread waiting for other thread to initialize a communication or to finish execution -> dead lock sceanrio..

synchronized keyword..
avoid nested loops, not lock unneccesarily, thread.join..

Git -> clear basics -> adding into repository, git init, git add, git commit, git push,  

git to be covered : stash, fetch, merge, rebase, status, pull, git branching

remote -> github profile
local -> your local machine

changes to be seen -> remote to local -> fetch
changes to be written and not seen -> git merge
changes to be seen and written to local -> git pull

git log -> history of changes

delete a commit from branch :

	git reset --hard commitId where you need to point 
	git push origin HEAD --force

branching:

merge : according to commit times, it will add to base repo (main/master)
rebase : put your changes at first
squash -> put your changes first but as a single commit..

branch -> git create branch_name
send changes to remote-> git push --set-upstream origin Bug_1616382

or directly from your remote repo..

switch your branches locally -> git checkout branch_name

upstream -> sending changes and receiving changes
downstream -> be default..from your branch

merge -> git merge branch_name (all the changes in other branch can be brought to your current branch)

Pull Request -> PR : to get approvals/reviews you will be raising a PR.

git stash -> put your local changes into a temporary place, get your remote changes
git stash show
git stash pop -> brings you stack of latest change
git stash apply ==== stash apply stash@{0} / last changes stash apply stash@{7}

******** 26/04/24: SQL Database & java Connectivity with SQL example *******

database -> organized collection of storing data..

DBMS -> Database Management System -> users & db...

	- hierarchal -> IMS
	- relational -> RDBMS --> SQL.. structured query language --> MySQL, MS SQL, PL/SQL(postgres),Oracle etc
	- object oriented -> Mongodb, Apache Cassandra, dynamodb, maria db, IBM Db2 etc -> non-structured db
	- network
	- non-relational
	- ditributed (multiple physical locations)
	- cloud, graph db

signup email -> login creds, email and pwd -> store these details in your db..

database -> collection of tables -> table has rows and columns

Installed MySQL Installer : https://dev.mysql.com/downloads/installer/

under this -> workbench, server,shell

shell -> https://www.mongodb.com/try/download/shell : download msi

dbeaver -> db tool -> connects to any db : https://dbeaver.io/download/

DB:
create database dbName
backup of your tables -> right click on a table & select export wizard..
drop database dbName 

show databases

Table:

create table dbName.tableName(ColumnName1 ColumnDataType1, ColumnName2 ColumnDataType2, etc )

create a new table from existing table:

create table dbName.newTableName AS Select existingColumnName1, existingColumnName2 from existingTableName

show tables

drop table tableName -> will delete the structure of your table
truncate table tableName -> will delete the data(rows) without effecting your table structure
	delete from schools; -> data from table -> delete rows, preseve columns
	delete from students where SchoolId = 6; for particular rows

truncate -> where condition is not present, can't rollback , DDL -> Data Definition Language(deals with table) : truncate,drop,alter,create table
delete -> where condition, rollback(insert), DML -> Data Manipulation Language(deals with data) : insert, update, select, delete etc


Insert into students(SchoolId,SchoolName) values(1,"abc"); -> add data newly into table
Select * from students; -> read data
	Select * from students where condition;
Delete from students where SchoolId = 1; -> removes particular data
  Delete from students;  -> removes all data from students
update students set SchoolName = "Stephens Mary" -> for all rows
	update students set SchoolName = "kalasala" where SchoolId = 2 -> for particular row  

ALTER:

Adding column to existing table
	Alter table students
	Add grades int;

Deleting an existing column

	alter table students
	drop column isCertified;

Rename an existing column
	Alter table students
	rename column grades to marks;

Add a column at particular position
		Alter table students
		Add isCertified boolean after SchoolName;

change the datatype of a column
		Alter table students
		modify column marks varchar(10);

Constraints : 

	PK -> Primary Key : not null and unique, one table can have one primary key
	FK -> creates a link between two tables
	Not null, Auto increment, unique, check, default

create table manager(
	ManagerId int not null Unique Auto_INCREMENT,
    FirstName nvarchar(50),
    LastName nvarchar(50),
    Primary key(ManagerId)
    );

create table employee(
	EmployeeId int not null Unique Auto_INCREMENT,
    ManagerId int,
    FirstName nvarchar(50),
    LastName nvarchar(50),
    Age int Default 18,
    Country nvarchar(50) default "India",
    Primary key(EmployeeId),
    Foreign key(ManagerId) references manager(ManagerId),
    Check (Age>=18)
);

Alias -> give some temporary name to a table or a  column

join -> SELECT columns from table1 join table2 on table1.column=table2.column
	 - Inner join, outer join, cross join(cartesian join), left, right

subquery/inner query -> select * from employee where ManagerId in (select ManagerId from manager); 
select * from employee where ManagerId not in (select ManagerId from manager); 
select * from (select * from manager where FirstName is not null && ManagerId > 1) employee
where ManagerId is not null;

select * from employee where EmployeeId not between 1 and 2;
select * from employee where EmployeeId between 1 and 2;

>,<, ==, !=

select coalesce(firstName,LastName) as FullName from manager;
coalsece -> (FirstName, LastName, n .. fields) -> it picks the first non-null value

\count... give you number of records
distinct -> unique records

select left(LastName,2) as ExtractedName from manager;
select right(LastName,2) as ExtractedName from manager;

limit/top 2 -> to get certain number of first records
select * from manager order by ManagerId desc;
select * from employee limit 3 offset 2;

Stored Procedure: for sql

USE `schools`;
DROP procedure IF EXISTS `manager`;

DELIMITER $$
USE `schools`$$
CREATE PROCEDURE `manager` ()
BEGIN
select * from manager; // query.. n number of lines here
END$$

DELIMITER ;

29/04/24:

union & union all on two or more tables -- columns level check

select ManagerId from employee union select ManagerId from manager union select StudentId from student; -- 3tables

select ManagerId from employee union all select ManagerId from manager

Aggregation : mathematical functions : multiple row functions
	- count : group by
	- min
	- max
	- sum
	- avg
	- like : select * from employee where FirstName like '%John%';
			 select * from employee where FirstName like 'John__';


INDEX : fetch data from db in a fast way..

array - [1,2,3,4,5,6,7,8,9,10] 
		--> linear search : for loop, 10 times.. complexity : O(n)
		--> binary search : divide your loop into half & you will search left & right --> 3 times.. O(log n)

select FirstName from employee; // before index normal pk order, after index, it gives dictionary order

create index idx_firstName
on employee(FirstName);

show indexes from employee;

alter table employee
drop index idx_firstName;

types of index -> clustered index(physical data) & non-clustered index(address of your physical data)..

n number of indices in a table.. can effect performance of write operations

master db -> write operations 
slave db -> copy of master -> read operations, indexes.. after particular period of time in case of new records -> copy from master db (syncing)

having clause:

SELECT COUNT(EmployeeId), age
FROM employee
GROUP BY age
HAVING COUNT(EmployeeId) > 0
ORDER BY COUNT(EmployeeId) DESC;

JDBC -> Java database connectivity
	- connectivity to sql, IDE build system
	- through maven

****************** MONGODB *****************

structure of data (columns) is not unique/changes from one row to other row -> no sql

to bring data -> join -> slow process

to avoid this -> JSON object.. Javascript Object Notation
 
 {
 	"empId" : 2;
 }

in sql -> db -> table -> records -> rows & columns
in mongo -> db -> collections -> documents -> json objects (can be unique)

 {
 	"empId" : 2;
 	"name" : "John"
 }

  {
 	"empId" : 3;
 	"name" : "Bob",
 	eventsAttended : [
 		"EventName1" : date,
 		"EventName2" : date,
 	]
 }

 https://www.mongodb.com/try/download/community -> server download
 For shell : https://www.mongodb.com/try/download/shell
 For GUI : https://www.mongodb.com/try/download/compass or https://robomongo.org/

Commands:

cls -> clear ur screen
show dbs
use databaseName -> if you have db use the db or else create a new db
db.dropDatabase(); -> delete a db

db.createCollection("collectionName")
show collections
db.collectionName.drop()

Insert :

	one ->  db.students.insertOne({name: "Peter", age : 15, dateOfJoining : Date(), isCertified : true})
	many -> db.students.insertMany([{ name : "Parker", age : 14, dateOfJoining: Date(), certificates : 2} , { name : "John", age : 17, certificates : 3}])

Read/Fetch data:

	db.students.find() -> all documents
	db.students.findOne() -> first document
	db.students.find({name : "Parker"}) -> where name is parker
	db.students.find({name : "Parker", age : 13}) -> where name is parker and age is 13

30/04/24 : remaining mongo commands : read queries, update, delete, operators(array), execution stats, index

	 db.students.find({},{name : "Parker", age:13}) // projection object
	 db.students.find({},{name : "Parker", _id:0}) // 0 or 1 is applicable only for id not on other fields

Update : 

	 db.students.updateOne({certificates:2}, {$set:{age:16}}) : only modifies first matched record
	 db.students.updateMany({certificates:2}, {$set:{age:16}}) : modifies all the matched records
	 db.students.updateMany({certificates:2}, {$set:{name : "Jill", age:16, lastModifiedDate: Date()}})
	 	add a new field to existing document
	 db.students.updateOne({certificates:5}, {$set:{name : "Jill", age:16, lastModifiedDate: Date()}}, {upsert:true})
	   if you don't have data, inserts data else modifies data

Operators: https://www.mongodb.com/docs/manual/reference/operator/update/

	db.students.updateMany({}, {$inc:{certificates:1}}) -> if nothing matches inserts the field else increments with the specified digit.
	db.students.updateMany({name:"Jill"},{$currentDate:{LastModifiedDate:true, ModifiedDate:{$type:'date'}}})
	 	pass any parameter in the first query braces.. currentDate setting in case of null or updating..
	db.students.updateMany({name:"Parker"}, {$currentDate:{LastModifiedDate:true, ModifiedDate:{$type:'date'}}}, {upsert:true}) -> inserts a record if document is  not present
	 $rename, $set, $unset -> try to write queries --> assignment

Array operators: 

	 db.students.updateMany({}, {$addToSet:{marks : {$each : [67,87,89]}}}) -> add array to all fields based on where condition
	 db.students.updateMany({}, {$pop:{marks: -1}}) -> removed 0th index element
	 db.students.updateMany({}, {$pop:{marks: 1}}) -> removed last index element
	 db.students.updateMany({}, {$addToSet:{marks : {$each : [67,89]}}}) -> adds at last index
 	 db.students.updateMany({}, {$push:{marks: 100}}) -> adds at last index
 	 db.students.updateMany({}, {$push:{marks: {$each:[82], $position:1}}}) -> at particular index to add an element
 	 db.students.updateOne({name:"Jill"}, {$pull:{marks:{$gt:90}}}) --> removed 100 marks for jill
 	 db.students.updateOne({name:"Jill"}, {$pullAll:{marks:[82]}}) -> removes the elements in array for jill

 	 try adding and updating a map object in a document

 	 // Update an existing document to add a map
	db.collection.updateOne(
  	{ _id: ObjectId("document_id") }, // Specify the document to update (replace "document_id" with the actual ID)
  	{ $set: { myMap: { key1: "value1", key2: "value2", key3: "value3" } } } // Set the map field with key-value pairs
	);

	// Insert a new document with a map
	db.collection.insertOne(
  	{ myMap: { key1: "value1", key2: "value2", key3: "value3" } } // Insert a document with a map field
	);


Delete Operations:
	
	db.students.deleteOne({}) -> removes first record
	db.students.deleteMany({}) -> removes all records
	db.students.deleteMany({name:"Packerson"}) -> deletes those records which satisfy the where condition

	Execution Stats : db.students.find({certificates:3}).explain("executionStats") -> gives all the detailed info on the query.

	Index :

		db.students.createIndex({'certificates':1}) -> 1 is ascending order, -1 descending order

		again check the execution stats, the doc examined count decreases.

		db.students.getIndexes() -> see available indexes

		db.students.dropIndex("certificates_1") -> delete an index

			types : single field -> on one field
			        compound -> two fields index
			        multikey -> array
			        text -> string
			        wildcards -> fields varying from doc to doc
			        hashed index -> hashed mechanism
			        geospatial index -> 2dsphere, legacy coordinates..


02/05/24 : comparison operations, aggregate functions, mapping a collection to array, var, validation in mongo, connect mongo to java

Comparison : =, !=, > , >=, < , <=, in range and not in range

		db.students.find({product_price : {$eq : 655}})
		db.students.find({product_price : {$ne : 655}})
		db.students.find({product_price : {$gte : 655}})
		db.students.find({product_price : {$gt : 655}})
		db.students.find({product_price : {$lt : 655}})
		db.students.find({product_price : {$lte : 655}})
		db.students.find({marks : {$in:[82,67]}}) -> for an array/field
		db.students.find({marks : {$nin:[67]}}) -> for an array/field

Query Operators : https://www.mongodb.com/docs/manual/reference/operator/

Aggregate functions/operations/pipelines :

	 var profit = db.students.aggregate([{$match:{product_price:{$gt:474}}}])
	 	profit -> get results of above query.

	 db.students.aggregate([{$match:{product_price:{$gt:474}}}, {$count:"totalQuantity"}])
      result = [ { totalQuantity: 5 } ]

     db.students.aggregate([{$match:{product_price:474}}])
     
     db.students.aggregate([{$limit:3}]) -> first 3 records

     db.students.aggregate(([{$match: {product_price : {$gt: 70}}},{$group : {_id:"$product_material", totalPrice:{$sum: {$multiply:["$product_price", "$quantity"]}}}}, {$sort: {totalPrice: -1}}, {$limit:5}, {$project: {"_id":0}}]))

     join two collections:

      db.students.aggregate([{$lookup:{from:"products", localField:"_id", foreignField:"_id", as:"Details of the product"}}])

      https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/

var/const -> you can store your queries.

	const priceOperationStu = db.students.find().map(function(e){return e.product_price * 2}).toArray();
	NaN -> not a number
	priceOperationStu.length -> size of array

	for (const myElement of priceOperationStu){print ("Product price is: " + myElement/2)}

Validation in mongoDb, validate your schema:

registering student -> age of student dob year > 2010, int.. mobile num is mandatory, address.. validation Level : warn or error..

	json/bson javascript/ binary java script

db.createCollection("student", {
   validator: {
      $jsonSchema: {
         bsonType: "object",
         required: ["name", "year", "mobileNumber"],
         properties: {
            name: {
               bsonType: "string",
               description: "Must be a string and this is a required field"
            },
            year: {
               bsonType: "int",
               minimum: 2015,
               maximum: 3000,
               description: "Must be an integer. This is the date of birth year and should be > 2014 and < 3000"
            },
            mobileNumber: {
               bsonType: "long"
            },
            address: {
               bsonType: "string"
            }
         }
      }
   }, validationAction:"error" / "warn"
})

db.student.insertOne({name: "Peter", age : 15, dateOfJoining : Date(), isCertified : true, mobileNumber : NumberLong("9876454"), year :  2001})


Mongo to Java connectivity : add jar and write code

UI: vscode -> download

	--> html inspected and just saw basics
	-> semantics -> header, footer, article/section/nav-bar

margin, padding
To be discussed	responsiveness in a page 
bootstrap
js

03/05/2024:

codekata : Problem solving -> the way you approach problem/program.
webkata -> simple program

array - [1,2,3,4,5,6,7,8,9,10] 
		--> linear search : for loop, 10 times.. complexity : O(n)
		--> binary search : divide your loop into half & you will search left & right --> 3 times.. O(log n)

Like hackerrank, hackerearth, leetcode, their own compiler -> resembles guvi & we will be using this

divide & conquer -> analyze the problem -> pieces

assignment : 

	Formatting -> <b>, <sub>, <sup>, <mark>, <i>, <em>, <strong>, <del>, <small>, <ins>
	Quotation : <blockquote>, <q>, <abbr>, <address>, <cite>, <bdo>
	favicons :    <link rel="icon" type="image/x-icon" href="images/bridge.jpg">
	inline CSS, internal CSS, external CSS
	tables -> create a table, border-collapse, merge n number of rows/columns (
	colspan, rowspan, padding, spacing), vertical rows, colgroup
	<img>, <video>, <audio>
	
	<div> -> block level
	<span> -> short strings, styling
	id, class ->differentiation
	in a single h1 -> single element -> one id and multiple classes.
	semantic tags -> header, footer,navbar -> lists (unordererd, ordered), section, article
	forms -> validations., labels, inputs, textarea
	CSS -> grid, flexbox, overflow
	responsive css

hands-on: testimonals, flipcard	

border -> property around your html content
padding -> space btwn your text and border
margin -> space outside your border

font: 16px bolder Arial, Helvetica, sans-serif;

https://getbootstrap.com/docs/5.3/content/tables/#overview --> Bootstrap

06/05/24:

static website -> content is fixed & you don't expect any response.

JS -> Java script, TS -> type script, angular, react, node, vue etc -> dynamic applications

	html -> define content of web pages
	css -> specify the layout(styling) of web page
	js -> to program the behavior of web page : eg - fb login.. 

Internal JS -> inside a html code..
External JS -> outside html

DOM, BOM -> Document Object Model, Browser Object Model

Variables & keywords in JS : var, const, let, automatically assign a variable when undeclared : stores all datatypes

var -> you can redeclare -> hoisting.. drawback.. let keyword

var -> global variable is updated .. let -> doesn't update a global variable

const ----- final keyword in java

let length = 16
let height = 16.07
let shape = "rectangle"
let value = true
let x;

console.log(typeof length + " " + length);
console.log(typeof height + " " + height);
console.log(typeof shape + " " + shape);
console.log(typeof value + " " + value);
console.log(typeof x + " " + x);


Objects -> real time object -> properties & methods

JSON -> 

let car = "Tata"

const car1 = {
    type : "Tata", //variable1
    model : "2024", //variable2
    color : "white" //var3
}

console.log(typeof car);

console.log( car1.color);

Functions : no return type declared, store in a variable

function addNumbers(a,b) {
    console.log("Output will be ");
    return a + b;
}

console.log(addNumbers());

console.log(addNumbers(1,2,3));

console.log(addNumbers);

var result = addNumbers;

console.log(result(4,5));

pass function into an object & object inside an object:

 let person = {
    firstName: "John",
    lastName: "Doe",
    age: 30,
    graduated: true,
    company: {
      name: "TCS",
      salary: 100000,
      experienced: false,
    },
    fullName : function () {
      return this.firstName + " " + this.lastName;
    },
  };

  console.log(person.fullName());


Types :
	Named
	Arrow
	Anonymous 
	constructor
	generated

DataTypes : 

	let x = new String("queen");

	let y = new Boolean(true);

	let z = new Number();

 	let date = new Date();



	console.log(typeof x);

******************************* String Operations

let x = 1;
let y = "1";

console.log(x==y);	// .equals

triple equals :

let x = 1;
let y = "1";

console.log(x===y); // == in java

let x = "harry";
let y = new String("harry");

console.log(x === y);


let text = "mathematics"

console.log(text.length);

console.log(text.at(0));
console.log(text[0]);
console.log(text.charAt(0));

Assignment ::: Go through all the string operations in JS splice, slice, split, search, array methods : sort, foreach, filter, map, reduce, keys(indices, each index is a key)

Template Literals :

	let fName = "john"
	let lName = "doe"

	let welcomeNote = `Welcome ${fName}, ${lName}!`; --> back ticks

	console.log(welcomeNote);

Arrays:

Spread Operator :  	
	
	let num1 = [1,2,3,4]
	let num2 = [5,6,7]

	const combinedArray = [...num1, ...num2]

	console.log(combinedArray);	

Rest Operator : 

	function sum(...args) {
    for(let arg of args){
        console.log(arg);
    }
	}

	sum(1,2)

	sum(3,4,5,6,7,8,9)

const numbers = [12,28,9]  

// numbers.forEach(function display(val) {
//     console.log(val);
// })

numbers.forEach((val) => console.log(val))  ==> arrow function

const numbers = [12,28,9]

const keys = numbers.keys();

for(let key of keys){
    console.log(key);
} 

13/05/2024 :

Array Operations : 

create Array :

	const values = [1,2,3,"abc"]

	const value = [];
	value[0] = "first";

	const car = new Array("tata", "kia")

	values[0] ="name"; -> log it and see in console

	array to string -> car.toString

	for (let index = 0; index < car.length; index++) {
    const element = car[index];
    console.log(element);
	}

	car.forEach(e => console.log(e));  //arrow function

	function displayCar(val) {
    console.log(val);
	}

	car.forEach(displayCar); //consumer, supplier, function, predicate --> consumer functional interface

console.log( values.join(" * "));

values[7] = 100;


console.log(values);

console.log(values.filter( val => val > 2));

console.log(values.map( val => val * val));

console.log(values.reduce((total, val) => total + val, 0));

for(let key of values.keys()){
    console.log(key);
}


const cars = [
    {type: "tata", year : "2017"},
    {type: "hyundai", year : "2014"},
    {type: "kia", year : "2020"}
]

console.log(cars.sort((a,b) => a.year - b.year));

console.log(cars.sort((a, b) => a.type.localeCompare(b.type)));


Read about : push, pop, shift, concat, unshift, flat, slice, splice, reverse


SET :::::

	const alphabet = new Set(["a", "b", "c"]) // set from an array

     const letters = new Set();
	letters.add("x")
	letters.add("y")
	letters.add("z")

	const letter1 = "d"

	letters.add(letter1);
	letters.add(1);


	console.log(alphabet);

	console.log(letters);

	console.log(letters instanceof Set);

	console.log(letters instanceof Array);

	let arr = Array.from(letters);
	console.log(arr instanceof Array);

	console.log(letters.has("a"));

	letters.forEach(val => console.log(val));

Set methods : keys, size, entries


MAP :::::::::::::::::::

	const fruits = new Map();
	fruits.set("apple", 100)

	console.log(fruits);

	const fruits = new Map([["bananas", 110], ["orange" , 200]]); // create map from array


	console.log(fruits.get("apple"));
	console.log(fruits.size);

	console.log(fruits.delete("apple"));

	console.log(fruits);

	fruits.clear();

	console.log(fruits.has("apple"));


forEach, values, keys, entries

JS Errors :::::::::


	try {
        console.log(1/0);
        console.log("hi");
        console.log(add());
	} catch (error) {
    if(error instanceof ReferenceError){
        console.log("Please check your input"); // custom message
    }
	}finally{
    console.log("Inside finally block");
	}

	throw keyword -> an example JS

"use strict"
 	x = 3.14 //declare with let/var/const

	add()

	function add(){
		"use strict"
 	   y = 22.7; //declare with let/var/const
	}

	console.log(x);

Binding using this keyword:

  const person1 = {
    fullName : function () {
        return this.firstName + " " + this.lastName;
      }
  }

  const person2 = {
    firstName : "Harry",
    lastName : "Potter"
  }

console.log(person1.fullName.call(person2)); //binding using "this keyword"


Constructor :::::::::::

	class Car{
    constructor(name, year){
        this.name = name;
        this.year = year;

    }
    age(param){
        return param - this.year
    }
	}

	const car = new Car("tata", 2020);
	console.log(car.age(2024));

Getters & Setters -> Object Accessors


	const person = {
    name : "John",
    language : "",

    get person_name(){
        return this.name.toUpperCase();
    },

    set lang(lang){
        this.language = lang.toUpperCase();
    }
	}

	console.log(person.person_name);

	person.lang = "en";

	console.log(person.language);

Inheritance in JS :

class Car{
    constructor(brand){
        this.brand = brand;
    }
}

class Model extends Car {
    constructor(brand, mod) {
        super(brand);
        this.model = mod;
    }

    show() {
        return this.brand + ', It is a ' + this.model + " model" ; // Access brand directly
    }

    static display() {
        console.log("From static method");
    }
}
const car = new Model("TATA", 2024);
// console.log(Car.display());
Model.display(); // Correct way to call static method
console.log(car.show()); // Call instance method


JS remaining concepts : json parse, prototypes, file operations, call back, asynchronous, promises, await === async, fetch API

14/05/24:

JSON PARSE/STRINGIFY :::::::::


let obj1 = JSON.parse('{ "type" : "Tata", "model" : "2024", "color" : "white"  }')

console.log(obj1 instanceof Object);

const car = '["kia", "BMW", "tata"]'
const arr = JSON.parse(car)

console.log(typeof arr);
console.log(typeof car);

let stringJSON = JSON.stringify({ "type" : "Tata", "model" : "2024", "color" : "white"  })

console.log(typeof stringJSON === 'string');

parse -> converting a string into Object
stringify -> converts an obj to string

PROTOTYPES :::::::::::

function Person(fName, lName) {
    this.firstName = fName;
    this.lastName = lName;
}

// console.log(Person.prototype); --> inspect and see in browser tab

const father = new Person("John", "Doe")
const mother = new Person("Ana", "Doe")

// Person.age = 40; // undefined

Person.prototype.age = 40;

console.log(father.age);

CLOSURES ::::::::

global & local variables:
	global -> can have access to all the functions/methods inside a particular file
	local -> can have access only for that specific function/method in a class/file


	//  let counter = 0; //global variable

function add() {
    var counter = 0 //global variable
    var counter = 1
    function plus() {
        let counter = 1;
         counter +=1 //local variable
    }
    plus();
    return counter;
}



add();
add();
add(); //counter is 3 in case of global variable

// function sub() {
//     counter -=1;
// }

// sub();

// console.log(add());

const selfFunction = (function () {
    let counter = 0;
    return function () {
        {
            counter +=1;
            return counter;
        }
    }(); //inner function, which is self invoking
})(); //self invoking function

console.log(selfFunction);
console.log(selfFunction);


CALLBACK :::::::::::

function display(val) {
  console.log(val);
} // call back function

function add(a, b, func) {
  let sum = a + b;
  func(sum);
}

console.log(add(4,5, display));

setTimeout(function(){display("Welcome! From anonymous function")}, 3000)

setTimeout(() => display("Using Arrow Function!"), 3000)

console.log("From code");

File Read Operation ::::::::::::: 

const fs = require("fs")

function display(err, data) {
    if(err){
        console.log(err.message);
    }else{
        console.log(data);
    }
}

fs.readFile("file11.txt", "utf-8", display)


fs.readFile("file1.txt", "utf-8", (err, data) => {
    if(err){
        console.log(err.message);
    }else{
        fs.readFile("file2.txt", "utf-8", (err, data1) => {
            if(err){
                console.log(err.message);
            }  else{
                //add one more readFile for third file..
                console.log(data);
                console.log(data1);
            }
        })
        
    }
})


PROMISES ::::::::::::::::: to avoid writing n number of if blocks in above case, we go for a promise

let myPromise = new Promise((myResolve, myReject) => {
  let x = 0;

  if (x <= 0) {
    myResolve("OK! x is zero");
  } else {
    myReject("Please check x value, Error!!!!");
  }
  setTimeout(() => console.log("Finished Processing"), 3000);
});

console.log(myPromise); //check in browser tab

myPromise
  .then((value) => console.log(value))
  .catch((error) => console.log(error));

States : fulfilled, pending, rejected

let myPromise = new Promise((lessThan, greaterThan) => {
  let x = 9;

  if (x > 10) {
    lessThan("OK! x is less than");
  }
  if (x < 10) {
    greaterThan("Greater Than");
  }

  setTimeout(() => console.log("Finished Processing"), 3000);
});

// console.log(typeof myPromise);

myPromise
  .then((lessThan) => console.log(lessThan))
  .catch((greaterThan) => console.log(greaterThan));

  Applying promises on Files:

  const fs = require("fs");
const { promisify } = require("util");

const readFilePromise = promisify(fs.readFile);

readFilePromise("file1.txt", "utf-8")
    .then((data1) => {
        console.log(data1);
        return readFilePromise("file2.txt", "utf-8"); // Return the promise
    })
    .then((data2) => {
        console.log(data2);
        return readFilePromise("file3.txt", "utf-8"); // Return the promise
    })
    .then((data3) => {
        console.log(data3);
    })
    .catch((error) => console.log(error));

OR ::::

const fs = require("fs").promises;

fs.readFile("file1.txt", "utf-8")
    .then((data) => {
        console.log(data);
        return fs.readFile("file2.txt", "utf-8"); // Return the promise
    })
    .then((data2) => {
        console.log(data2);
        return fs.readFile("file3.txt", "utf-8"); // Return the promise
    })
    .then((data3) => {
        console.log(data3);
        return fs.readFile("file3.txt", "utf-8"); // Return the promise
    })
    .catch((error) => console.log(error));


Async & Await, without this the promise will be in a pending state::: here::


  try {
    let data1 =  fs.readFile("file1.txt", "utf-8");
    let data2 =  fs.readFile("file2.txt", "utf-8");
    let data3 =  fs.readFile("file3.txt", "utf-8");
  
    console.log(data1);
    console.log(data2);
    console.log(data3);
  } catch (error) {
    console.log(error);
  }


  WIth Async and await


const fs = require("fs").promises;


 async function displayFiles(){

  try {
    let data1 = await fs.readFile("file1.txt", "utf-8");
    let data2 = await fs.readFile("file2.txt", "utf-8");
    let data3 = await fs.readFile("file3.txt", "utf-8");
  
    console.log(data1);
    console.log(data2);
    console.log(data3);
  } catch (error) {
    console.log(error);
  }
  
}

displayFiles();


Revise : java 8 features... streams, functional interfaces & types of FI, lambda expression, optional, date time api, comparator vs comparable; default, private & static methods in an interface, reduce, Method references, Callable & Future Interfaces, Completable Future & Completion Stage

15/05/2024 : Fetch API, Java 9-17 features..

Fetch :::


fetch('https://reqres.in/api/users?page=2')
  .then((res) => res.json())
  .then((res) => console.log(res));


  const fetchUserInfo = async () => {
    try {
        const response = await fetch('https://reqres.in/api/users?page=2')
    
        //parse json response
        const userData = await response.json()
    
        console.log(userData);
    } catch (error) {
        console.log(error.message);
    }
}

fetchUserInfo();

axios() -> something similar to your fetch apis

fetch post request..

Java 9-17 Features:

Contents:

● Private methods in interface - covered already in second session
● Collectors API & Immutable Collections - done
● Var keyword - done
● File APIs - done
● Switch expressions - done
● Text blocks - done
● Records - from java 14

read about sealed,non sealed classes. Scanner changes from Java 9, auto closeable.


File APIs :; delete a non-existing file, exception won't be thrown., Buffered Writer, Files.writeString


16/05/24 :: IOC & Dependency Injection, Spring framework

backend server/application -> 24*7.. --> 

	req ---> send to your back end app/server (process your information) --> response

	ui -> n number of filters here (validate your request), mulesoft, ping federate, etc -> backend API -> interact with your db and send you the response (validate your response)...

Java EE (Enterprise Edition) -> JSP(java server page) + Servlets(ui + java code) + JSF etc..

Java -> spring framework.. evolutions.. mvc/boot/batch

pros of spring : 
	less code
	configurations is maintained by spring
	reduces boiler plate code... section of code, which is repeated through out the app with little or no changes at all.
		10 public methods -> same logic repeated.. in almost 8 methods..

IOC - Inversion Of Control.. spring tc of obj creation, destruction, obj lifecycle
DI - Dependency Injection.. constructor injection, setter injection, class/field injection

spring-context : https://mvnrepository.com/artifact/org.springframework/spring-context

AOP - aspect oriented programming.. concerns like your classes..

beans : obj managed by spring
spring-context/container -> has all the beans

cricket/football coach -> depends on  happy wish service
	-> setter injection
	-> constructor
	-> set properties
	-> scope -> bean life cycle
		singleton -> obj created and destroyed
		prototype -> only created


.properties or .yml file...	

17/05/2024:

component-scan : read the base packages of your application..

@Component -> is responsible for bean creation

@Autowired -> injection 
				: constructor -> mandatory fields
				: setter -> optional fields
				: field/class level

@Value -> to read properties
@Scope("prototype") or @Scope(value = BeanDefinition.SCOPE_PROTOTYPE)
@PreDestroy & @PostConstruct

In config file:

@Configuration
@ComponentScan("com.spring.demo")
@PropertySource("sports.properties")

@Qualifier("happyWishService") -> if you have two beans and no name defined, you go for this to pick something as default
	: constructor/setter/field level injection

@Primary --> at the bean level you can use, if you have multiple beans injected
	: class-level

@Bean -> third party libraries


Spring MVC -> inbuilt server/ use a apache tomcat server..
	Model -> data of app
	View -> displaying user., thymeleaf/jsp page
	Controller ->	handling user requests

Spring Boot -> inbuilt tomcat server -> you can change your server by adding dependency of any other server
	: auto-config & start..	

Dispatcher Servlet -> handles all incoming http req -->	invokes appropriate ctrl class, this acts as front ctrlr.. 

	request -> ctrlr -> service -> repository -> bean/dto/pojo/entity..

lombok :
	@Data
	@AllArgsConstructor
	@NoArgsConstructor

Log : slf4j vs log4j
	info, debug, error

@Controller -> built on top of component, rep of ctlr class
@Service -> built on top of component, rep of service class
@Repository -> built on top of component, rep of repository class
@RestController -> rest api + @ctrlr + @ResponseBody

@RequestMapping(method = RequestMethod.GET) ======= @GetMapping
	: @GetMapping, @PostMapping, @PutMapping, @PatchMapping, @DeleteMapping
		put vs patch -> update a resource; 
			put -> whole resource & patch -> only the changed value..
			put -> creates a new resource if resource doesn't exist, patch -> only field changes no changes on resource level


@PathVariable -> to read params from URI
@RequestBody -> to read your object from request
@RequestParam -> to read your query parameters
		& -> and , % -> or
@RequestMapping("api/student") -> at ctrlr class level -> fixed endpoint/path for a service		


API -> communication btwn component ::::: CRUD -> Create, Read, Update & Delete

	Post : inserting some data into db
	Get : fetches the info from db
	put/patch : update
	delete : delete specified data


http://localhost:8080/call-app
	http : protocol / https :  secured
	localhost : app is hosted on/ running / served --> base URI
	8080 : port
	call-app : end-point

Status Codes:
		1XX -> information
		200, 201, 204, 2XX -> API Info
		3XX -> redirectional
		404, 4XX -> client side
		5XX -> server

20/05/24 : remaining methods in ctrlr..

*********** Hibernate & JPA ***************

JDBC -> interact db & java code

hibernate & jpa -> simpler way..
	: Java Persistence API -> lib, hibernate under JPA..
	: hibernate-config.xml -> configuration
@Entity
@Table(name = "persons")

PK : @Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)

Column level :
	    @Column(name = "FirstName", nullable = false, unique = true)

ORM : Object Relational Mapping..
	RelationShips:	
		OneToMany
		ManyToOne
		ManyToMany
		OneToOne


	One Person can have Many Orders..	

21/05/24 -> spring data jpa/mongo---> sql & mongo	

req -> ctrlr -> service -> repo -> again it fetches ur res and send back to service and to ctrlr

	spring data jpa proj creation ->
		app. props -> connection details
		created an entity

	@Repository -> on a repo layer	
		<EntityClass, type of PK> -> generics to any extension of a repo.
		service methods & impl
		ctrlr
		tested the app

spring aop : Aspect Oriented Programming.. 

spring-data-mongodb:

	download the project from initialzr

		@Document(collection = "product") -> at dto/entity level

Optimistic & Pessimistic Locking : 10,000 -> upi I remove 6,000 & from atm -> 5,000... 	
			: locking -> prevent simultaneous access to a data in a system/application

		Optimistic : timestamps, versions.. object level
		Pessimistic : memory level lock, serializable... transaction isolation level... -> read_committed, read_uncommitted, repeatable read, serializable
			on a service/repo layer :   @Transactional(Isolation.SERIALIZABLE)

		ACID : Atomocity, Consistency, Isolation, Durability...

TO-DO : finish remaining end-points in your spring-data-jpa...

22/05/24 -> spring mapping, exception handling in boot, validation in boot

Mapping : vulnerabilities.. obj oriented model -> relational model

	ctrlr ---> obj(Java, data transfer object) ---> service (map your dto with entity (db obj)) ---> entity to repo... again vice versa

basic mapping -> creating an UserMapper
ModelMapper -> mapper.map(source, destination)	

validate req body -> spring-validation, @Valid, @NotEmpty

Field level validations : https://www.bezkoder.com/spring-boot-validate-request-body/


23/05/24 -> swagger(API documentation), actuator, servlets

spring actuator -> you can the status of your application for management/monitoring -> health, metrics, info.. 14 endpoints in this..

	actuator : 
		/actuator -> available endpoints
		/health
		/info
		/beans
		/mappings
		/configprops
		/metrics
		/metrics/any endpoint you see from /metrics
		/env
		/cache
		/condition
		/loggers
		/scheduledtasks
		/shutdown


Swagger :
	swagger 2 -> walkthrough
	swagger 3 -> add dep in app & customisation at app level, ctrlr level, schema level..


Servlets :	
 new project with web-app archetype -> configure tomcat, run the app


Spring Security : 

		verifying identity -> authentication.. emp or a non-employee
		grant access level -> authorization.. admin user and normal user for an employee

demo -> 
	downloaded from spring initializr
	created simple basic apis
	saw authentication from generated password through console (during app start up)
	debugged the application to see where internally our username and password are filtered
	saw authentication by defining user and password in app.props

	added configuration to allow our post requests as well..

	method level authorization -> through configuration
	method level authorization -> through controller
		- 401 unauthorized -> not authenticated.. wrong credentials
		- 403 forbidden -> if user is not authorized to access an API

	 
	authentication by storing this user and password in db..


27/05/24

ManyToMany

	  users	  			roles
	 1(john)          1(admin)
	 1(john)          2(user)
	 2(harry)         1(admin)
	 3(peter)         2(normal user)	
	 3(Peter)         3(waiter role)

Dao ==== repository

    - created a CustomUserDetailsService instead of using the spring inbuilt one

AuthenticationFilter -> AuthenticationManager -> ProviderManager -> AuthenticationProvider -> DaoAuthenticationProvider -> UserDetailsService

JWT --> Json Web Tokens --> hashed token used to authenticate API..

	- generated JWT using a post request in controller
	- create a custom Authentication Manager..
	- create jwtUtil to validate the bearer token
	- using the jwt token -> hit the end points..

28/05/24:

Spring webflux & reactive streams..	

	reactive - reactive programming & alternative to mvc
		- asynchronous & non-blocking apps
			blocking/synchronous -> user waits for data before performing execution
			non-blocking -> user won't wait for anything

Normal Scenario :

req to API -> dispatcher servlet (handles routing to controllers) 

Blocking model(mvc/boot/web) :

	1 thread ---> 1 API (by default you can handle 200 API calls..)	
	2000 threads -> an issue at future...if you have millions of data..

To overcome this -> reactive model..

API Call --> event loop (like your node js) 24 * 7 reload symbol -> non-blocking reactive stream -> process req by allocating other threads..

Flow.java -> from Java 9

	- publisher : publish events : db/api call
	- subscriber : to events : ctrlr.. will listen to published events
	- subscription : listen to subscribe..

r2dbc -> sql servers -> spring reactive web app -> an exmp to connect through repo..
		
  @Query("SELECT * FROM employee WHERE last_name = :lastname and first_name = :firstname")
    Flux<Employee> findByLastName(String lastName, String firstname);

reactive mongodb -> mongo connections

Flux -> 0 to n responses -> any number
Mono -> 0 or single (1) response..

Instead of ResponseEntity : 

    @ResponseStatus(value = HttpStatus.CREATED)

getAllEmployees -> 
	serversideEvents -> stream responses -> zip and send n number of events..

29/05/24:

Spring Batch : deals with bulk data & whenever to execute particular some frequent intervals of time..

1. Salary -> last working day/first day/particular day of every month.. scheduled jobs
2. user table -> changed to employee table(same/diff db) -> migration, oracle to postgres sql..
3. emp from comp y -> data (pf data, remarks etc csv file)., our company x -> import the csv from y comp and process this csv..

comp x -> import csv -> write to db
comp y -> export csv -> from db

demo project

	Steps :

	  - 1. Reader -> read values from your db / csv file
	  - 2. Processor -> generate sql statements & handle any logic
	  - 3. Writer -> write the queries to your db..


devops use -> main branch to deploy.. (git link)

bug -> push your code to a branch (which is not main) bug_branch -> PR (reviewed & approved by your fellow colleagues..) -> once pr is approved -> merge your PR with your main 
	- build & deploy :
		1. you can do manually.. jenkins/ platform, build your application
		2. when ever your main branch has a change in 5minuts(could be any time) -> a build will be automatically trigerred & deploy as well
			- build : you do all the maven steps (run, install, clean, sonar, junits running, checks/validations)  & finally give you a jar file
			- deploy : put this jar / replace the old jar into your specified env..

Dev-tools -> see a change in your code (app should be running)/ redeploy the code
	With DevTools when we make changes to Java code or properties file, the application gets updated with new changes. It monitors for changes and automatically restarts the application
	 - maven/gradle dependency		

30/05/24:

Spring JMS -> Java Messaging Service

	- queue for sending, receiving, reading a msg -> rabbit mq, kafka, active mq, apache mq, ibm mq etc..

MS1 -> rest API(or message) -> MS2    

Message driven communication in case of message

MS1 ----> ms2 and MS1 ---> ms3... One MS to many MSs...

Msg driven -> ms1 ->send a msg ms2, ms3.. one publisher and multiple subscribers.. One to many communication..

1 -> 1 service--> Queue
1 -> many services -> Topic

spring-jms-demo :

	1. downloaded project
	2. download docker desktop
	3. activemq docker command in cmd : docker run --detach --name mycontainer -p 61616:61616 -p 8161:8161 --rm apache/activemq-artemis:latest-alpine


Email -> Receiver -> configure	

created a sender and sent email messages..

the java package name of a sender and receiver should be same

you can check more details on http://localhost:8161
	
	username : artemis
	password : artemis (whatever you define in app.props)

**** spring cloud & microservices Intro: ****

	monolithic architecture -> single application, single service..
	microservice architecture -> 

	amazon/flipkart -> product search service and payment service.. n users.. both services load 2million times..
		-> prod search service -> 2million times
		-> payment service -> only when req..
		-> order service..

		Scaling -> resources handle load

ms1 -> sql db., ms2 -> oracle db, ms3 -> postgres db & python.. ms4 -> node.js & node, ms5 -> vue.js & java ---> as a unit..

Cons :
	easy to scale
	each ms --> 1 functionality.. easy to maintain & test..		
	different ms (microservice) -> can have different technologies


Communication -> product id in payment service or payment txn id in orders service
		 sync : search, payment -> search will wait & vice-versa..
		 async : both don't co-ordinate i.e., search & payment won't wait for each other

100 ms -> different ports -> maintain & track..

	client (UI) -> ms1/ms2/... API gateway -> fwds req to respective ms (uses service discovery to fwd req)..
	ms is down -> circuit breaker pattern
	app.properties -> Config Server ... configuration of ms..
	one ms -> can have n number of instances ( copy of your application ) -> service registry / discovery (Eureka Server)
	  - register your services , track for discovery 
	To track an API call (ms communication) -> distributed tracing
	bus refresh & rabbit mq
	
Spring Cloud framework -> all above features + additional features..

31/01/24:

Demo-application two ms :
	1. Employee Service -> Post & Get end-points & get endpoint depends on Dept Service
	2. Department Service -> Post & Get end-points


Dept --> get dept by Code...

Emp -> you have a code --> using this dept code I need details of dept service..

ms communication

	- RestTemplate
	- Spring Open Feign
	- Web Client 


03/06/34:

REST (Representational State Transfer) vs Soap (Simple Object Access Protocol) vs GraphQL

	Rest : xml, html, image, any form of files, json, flexible -> multiple requests
	Soap : xml, many preconditions -> code in xml
	graphql : developed by FB.. -> a single request can handle multiple endpoints..
		 -> graph ql example: https://spring.io/guides/gs/graphql-server

Unit Testing:

app -> func like getEmployee (unit) or saveEmployee (unit)

function :

public int add(a, b){
	return summation(a,b); // summation is a different private method.., in case of other class call you will mock/dummy the object..
}

	test cases : 
		1. whole numbers
		2. negative numbers
		3. rational or irrational numbers
		4. decimal numbers

Actual Vs Expected :
	actual -> your code logic
	expected -> expecting some result
	Assertions -> equal, not equal, true or false, etc

getEmployee 
	1. 	correct id and get employee details -> success scenario
	2.  incorrect id -> which doesn't exist in db and you should get a resource not found exception -> negative scenario

Test case Steps :

	1. initialize the req parameters to test
	2. create mock objects
	3. call the method which you are going to test (from step 1)
	4. assert if your actual result matches with expected result.

Add junit dependency..

Test Cases Concatenate :

	1. normal case : send 2 strings..
	2. empty strings as i/p -> see result
	3. empty firstName 
	4. empty lastName
	5. null firstName
	6. null secondName
	7. both null

TDD & BDD..

Annotations :
	@Test, @AfterEach, @AfterAll, @BeforeEach, @BeforeAll

Tests : normal classes where your have functions..
we shall not write a test case for application main method, interface, enum --> exclude in sonar/jacoco exclusions..	

 Mockito, mock stubbbing, practice by commenting annotations..