Java 
core java - super, this, final keywords, generics, recursion, collections(tree, graph,dequeue and queue), Optional (streams, lambda, functional interface),exception handling, Date timeAPI,Comparable vs Comparator.. memory management & garbage collection,
file handling, multithreading & concurrency

Git -> clear basics -> adding into repository, git init, git add, git commit, git push,  

git to be covered : stash, fetch, merge, rebase, status, pull, git branching

sql -> from scratch, jdbc connectivity

codekata -> walkthrough --> done -->  i/p stream & o/p stream.. java new features... 

javascript -> 1/2hr only taken, but not clear.. bootstrap.. html and css (margin, padding) -> react course videos will be received.

*************************
18/04/24.
matrix problem
reading i/p from user
codekata

Problem solving skills -> 

divide and conquer..

IDE -> eclipse, sts (spring tool suite) -> almost similar
IntelliJ -> advanced features.. two types 1. community edition (free and open source), 2. ultimate edition (paid, free tier for first 15-30days)

jdk -> open jdk : oracle/amazon

jdk version should be compatible with IDE..

version 1 -> your game app..
playstore/app store -> version 2.. 

22/04/24

New Project -> select language, select build tool -> maven, gradle

packages -> classes -> methods/functions -> objects or variables (local & global)

.jar(.exe) -> build tools..

core java - super, this, final keywords: 

this : refers to current object 
super : refers to superclass or parent methods or variables
final : can't modify a value (variable), in case of class -> can't extend., method level -> can't overrride method

immutable -> can't modify 
	. make your class as final
	. make your fields as private
	. you will not have setters only getters
	. mutable fields final
	. initialize using a constructor

generics -> ensure type safety
	generic class(List), type parameters : T -> type, E -> element, K -> key, N -> number, V -> value
	generic method
	type casting -> from one data type you are converting to datatype

recursion -> making a function to call itself

collections -> framework (store data & manipulate data) -> search, sort, insertion, manipulation, deletion etc

				Iterable(interface)
				    ..

				  Collection

		List        Queue        Set     Map  


List -> insertion order, any number of null values
	ArrayList :  non-synchrnoized : add, remove, contains, get
	LinkedList :  non-synchrnoized : add, remove, contains, get
	Vector : synchronized : add, remove, contains, get
		. stack : push(add), insertion order Last In first Out : pop(remove), peek(top element), get

synchronous -> one action happens only at one time.. Collections.synchronizedList()

Queue : First in First Out : poll, remove, contains, peek, element
	. Priority queue - no insertion order
	. array dequeue - insertion order

Dequeue : add/delete the elements either at last or first position	

23/04/24

Set -> doesn't allow duplicates
	hashSet: not following insertion order, add, remove, contains., no indexing concept so get is not present.., one null will be allowed
	linkedhashset : follows insertion order, one null can be allowed
	treeSet : ascending order, no null values allowed, in case of null values -> run time exception

Map : store data in form of keys and values.. Keys will be unique, values can be duplicated


	Map<Integer, String> hashMap = new HashMap<>();
	hashMap.get(key) -> values
	hashMap.remove(1); -> remove both key and value
	hashMap.keySet() -> give you all the keys
	hashMap.containsKey(1) -> to check keys
	hashMap.containsValue("jill") -> to check values
	hashMap.entrySet() -> keys and values

	hashMap : One null key and multiple null values.
	treemap -> doesn't allow null key

hashtable, linked hash map.

stream API -> to process any collection of data	

Optional -> filter, map, entryset.stream

terenary operator -> condition ? true (statement will be executed) : false (whatever written here will be executed) --> if-else

Functional Interface -> @FunctionalInterface,

single abstract method, default or static or private methods in this..

abstract method in an interface should be overridden by the implemented class..

Types of functional interfaces -> Function, Consumer, Supplier, Predicate

Exception Handling:  (try, catch, finally, throw, throws)

	custom exception : extends exception, call parent constructor

DateTime API : changes in Java 8 -> Zoned, LocalDateTime, ChronoUnits, LocalDate, LocalTime, Period, Duration	

24/04/24:

Comparable vs Comparator.. file handling, memory management & garbage collection,

Comparable / Comparator -> sorting

File handling : create, read, update, delete, search

Asssignment:
create a folder -> 10 excel files with different names, using Java check if file exists or not and then if file is present delete a particular file. FileInputStream, type of functional interface

memory management & garbage collection:

Object destruction in JVM -> handled by garbage collector(GC), however few objects may not be eligible for GC then you will know to know how your memory is managed.

-Xmx2g
-Xms1g

string Pool -> FlyWeight Design Pattern

25/04/2024:

multithreading & concurrency, git commands

threads.. running llely, 
concurrency -> illusion that threads run parallely but real-time, they actually switch..

thread lifecycle -> new thread -> start() -> runnable -> run() -> runnning -> either wait for another thread or dead (execution ends)

payment process -> thread
receipt -> other thread..

when you wait for some thread to finish execution it's synchronous 
sign up to a site -> welcome email, even though you don't buy anything.. if you are not waiting for other thread or depending thread to finish execution -> asynchronous..

Thread Prioroties -> MAX_PRIORITY -> 10.. 

extending a thread, implementing Runnable/Callable -> create  a multi threaded environment.

Thread.interrupted -> wake up a sleeping thread

   System.out.println(Thread.currentThread().getName());
   Thread.currentThread().setName("Custom Name");

 Thread.join(); -> before start and after start.
 thread.setPriority(10) -> high

 one thread waiting for other thread to initialize a communication or to finish execution -> dead lock sceanrio..

synchronized keyword..
avoid nested loops, not lock unneccesarily, thread.join..

Git -> clear basics -> adding into repository, git init, git add, git commit, git push,  

git to be covered : stash, fetch, merge, rebase, status, pull, git branching

remote -> github profile
local -> your local machine

changes to be seen -> remote to local -> fetch
changes to be written and not seen -> git merge
changes to be seen and written to local -> git pull

git log -> history of changes

delete a commit from branch :

	git reset --hard commitId where you need to point 
	git push origin HEAD --force

branching:

merge : according to commit times, it will add to base repo (main/master)
rebase : put your changes at first
squash -> put your changes first but as a single commit..

branch -> git create branch_name
send changes to remote-> git push --set-upstream origin Bug_1616382

or directly from your remote repo..

switch your branches locally -> git checkout branch_name

upstream -> sending changes and receiving changes
downstream -> be default..from your branch

merge -> git merge branch_name (all the changes in other branch can be brought to your current branch)

Pull Request -> PR : to get approvals/reviews you will be raising a PR.

git stash -> put your local changes into a temporary place, get your remote changes
git stash show
git stash pop -> brings you stack of latest change
git stash apply ==== stash apply stash@{0} / last changes stash apply stash@{7}

******** 26/04/24: SQL Database & java Connectivity with SQL example *******

database -> organized collection of storing data..

DBMS -> Database Management System -> users & db...

	- hierarchal -> IMS
	- relational -> RDBMS --> SQL.. structured query language --> MySQL, MS SQL, PL/SQL(postgres),Oracle etc
	- object oriented -> Mongodb, Apache Cassandra, dynamodb, maria db, IBM Db2 etc -> non-structured db
	- network
	- non-relational
	- ditributed (multiple physical locations)
	- cloud, graph db

signup email -> login creds, email and pwd -> store these details in your db..

database -> collection of tables -> table has rows and columns

Installed MySQL Installer : https://dev.mysql.com/downloads/installer/

under this -> workbench, server,shell(optional)

dbeaver -> db tool -> connects to any db : https://dbeaver.io/download/

DB:
create database dbName
backup of your tables -> right click on a table & select export wizard..
drop database dbName 

show databases

Table:

create table dbName.tableName(ColumnName1 ColumnDataType1, ColumnName2 ColumnDataType2, etc )

create a new table from existing table:

create table dbName.newTableName AS Select existingColumnName1, existingColumnName2 from existingTableName

show tables

drop table tableName -> will delete the structure of your table
truncate table tableName -> will delete the data(rows) without effecting your table structure
	delete from schools; -> data from table -> delete rows, preseve columns
	delete from students where SchoolId = 6; for particular rows

truncate -> where condition is not present, can't rollback , DDL -> Data Definition Language(deals with table) : truncate,drop,alter,create table
delete -> where condition, rollback(insert), DML -> Data Manipulation Language(deals with data) : insert, update, select, delete etc


Insert into students(SchoolId,SchoolName) values(1,"abc"); -> add data newly into table
Select * from students; -> read data
	Select * from students where condition;
Delete from students where SchoolId = 1; -> removes particular data
  Delete from students;  -> removes all data from students
update students set SchoolName = "Stephens Mary" -> for all rows
	update students set SchoolName = "kalasala" where SchoolId = 2 -> for particular row  

ALTER:

Adding column to existing table
	Alter table students
	Add grades int;

Deleting an existing column

	alter table students
	drop column isCertified;

Rename an existing column
	Alter table students
	rename column grades to marks;

Add a column at particular position
		Alter table students
		Add isCertified boolean after SchoolName;

change the datatype of a column
		Alter table students
		modify column marks varchar(10);

Constraints : 

	PK -> Primary Key : not null and unique, one table can have one primary key
	FK -> creates a link between two tables
	Not null, Auto increment, unique, check, default

create table manager(
	ManagerId int not null Unique Auto_INCREMENT,
    FirstName nvarchar(50),
    LastName nvarchar(50),
    Primary key(ManagerId)
    );

create table employee(
	EmployeeId int not null Unique Auto_INCREMENT,
    ManagerId int,
    FirstName nvarchar(50),
    LastName nvarchar(50),
    Age int Default 18,
    Country nvarchar(50) default "India",
    Primary key(EmployeeId),
    Foreign key(ManagerId) references manager(ManagerId),
    Check (Age>=18)
);

Alias -> give some temporary name to a table or a  column

join -> SELECT columns from table1 join table2 on table1.column=table2.column
	 - Inner join, outer join, cross join(cartesian join), left, right

subquery/inner query -> select * from employee where ManagerId in (select ManagerId from manager); 
select * from employee where ManagerId not in (select ManagerId from manager); 
select * from (select * from manager where FirstName is not null && ManagerId > 1) employee
where ManagerId is not null;

select * from employee where EmployeeId not between 1 and 2;
select * from employee where EmployeeId between 1 and 2;

>,<, ==, !=

select coalesce(firstName,LastName) as FullName from manager;
coalsece -> (FirstName, LastName, n .. fields) -> it picks the first non-null value

\count... give you number of records
distinct -> unique records

select left(LastName,2) as ExtractedName from manager;
select right(LastName,2) as ExtractedName from manager;

limit/top 2 -> to get certain number of first records
select * from manager order by ManagerId desc;
select * from employee limit 3 offset 2;

Stored Procedure: for sql

USE `schools`;
DROP procedure IF EXISTS `manager`;

DELIMITER $$
USE `schools`$$
CREATE PROCEDURE `manager` ()
BEGIN
select * from manager; // query.. n number of lines here
END$$

DELIMITER ;

29/04/24:

union & union all on two or more tables

select ManagerId from employee union select ManagerId from manager union select StudentId from student;

select ManagerId from employee union all select ManagerId from manager

Aggregation : mathematical functions : multiple row functions
	- count : group by
	- min
	- max
	- sum
	- avg
	- like : select * from employee where FirstName like '%John%';
			 select * from employee where FirstName like 'John__';


INDEX : fetch data from db in a fast way..


array - [1,2,3,4,5,6,7,8,9,10] 
		--> linear search : for loop, 10 times.. complexity : O(n)
		--> binary search : divide your loop into half & you will search left & right --> 3 times.. O(log n)

select FirstName from employee;

create index idx_firstName
on employee(FirstName);

show indexes from employee;

alter table employee
drop index idx_firstName;

types of index -> clustered index(physical data) & non-clustered index(address of your physical data)..

n number of indices in a table.. can effect performance of write operations

master db -> write operations 
slave db -> copy of master -> read operations, indexes.. after particular period of time in case of new records -> copy from master db (syncing)

having clause:

SELECT COUNT(EmployeeId), age
FROM employee
GROUP BY age
HAVING COUNT(EmployeeId) > 0
ORDER BY COUNT(EmployeeId) DESC;

JDBC -> Java database connectivity
	- connectivity to sql, IDE build system
	- through maven

****************** MONGODB *****************

structure of data (columns) is not unique/changes from one row to other row -> no sql

to bring data -> join -> slow process

to avoid this -> JSON object.. Javascript Object Notation
 
 {
 	"empId" : 2;
 }

in sql -> db -> table -> records -> rows & columns
in mongo -> db -> collections -> documents -> json objects (can be unique)

 {
 	"empId" : 2;
 	"name" : "John"
 }

  {
 	"empId" : 3;
 	"name" : "Bob",
 	eventsAttended : [
 		"EventName1" : date,
 		"EventName2" : date,
 	]
 }

 https://www.mongodb.com/try/download/community -> server download
 For shell : https://www.mongodb.com/try/download/shell
 For GUI : https://www.mongodb.com/try/download/compass or https://robomongo.org/

Commands:

cls -> clear ur screen
show dbs
use databaseName -> if you have db use the db or else create a new db
db.dropDataBase; -> delete a db

db.createCollection("collectionName")
show collections
db.collectionName.drop()

Insert :

	one ->  db.students.insertOne({name: "Peter", age : 15, dateOfJoining : Date(), isCertified : true})
	many -> db.students.insertMany([{ name : "Parker", age : 14, dateOfJoining: Date(), certificates : 2} , { name : "John", age : 17, certificates : 3}])

Read/Fetch data:

	db.students.find() -> all documents
	db.students.findOne() -> first document
	db.students.find({name : "Parker"}) -> where name is parker
	db.students.find({name : "Parker", age : 13}) -> where name is parker and age is 13